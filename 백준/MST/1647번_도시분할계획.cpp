#include <iostream>
#include <vector>
#include <queue>
#include <stdlib.h>
#include <string>
#include <algorithm>
#include <climits>
using namespace std;

/*
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 
그러다가 평화로운 마을에 가게 되었는데, 
그곳에서는 알 수 없는 일이 벌어지고 있었다.

마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 
길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 
그리고 각 길마다 길을 유지하는데 드는 유지비가 있다.

마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 
마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 
마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 
각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 
마을에는 집이 하나 이상 있어야 한다.

그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 
일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 
그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 
항상 존재하게 하면서 길을 더 없앨 수 있다. 

마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 
이것을 구하는 프로그램을 작성하시오.
*/

int n,m,a, b, c,ans,pa,pb;
int parent[100000+1];
int max_wei = -1;
int Find(int a) {

	if (parent[a] == a) return a;

	return parent[a] = Find(parent[a]);

}

void Union(int a, int b) {
	if (a == b) return;
	pa = Find(a);
	pb = Find(b);
	if (pa != pb) parent[pa] = pb;
}

class Edge{
public:
	int start;
	int end;
	int weight;


	Edge() {
		start = 0;
		end = 0;
		weight = 0;
		
	}

	Edge(int st,int en,int wei) {
		start = st;
		end = en;
		weight = wei;
	}

	bool operator >(const Edge& e) const{
		
		return  weight > e.weight;
	}

};


priority_queue<Edge, vector<Edge>,greater<Edge>> edges;


int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);

	cin >> n >> m; // 집의 개수오 길의 개수가 주어짐
	//길은 양방향

	//초기화
	for (int i = 0; i < n; i++)
	{
		parent[i] = i;
	}

	for (int i = 0; i < m; i++)
	{
		cin >> a >> b >> c;
		edges.push(Edge(a, b,c));
	}


	//모든 edge에 대해 
	while (!edges.empty()) {
		Edge e = edges.top(); edges.pop();// 가중치가 가장 작은거 부터 뽑기

		//간선의 양 끝점이 이미 같은 집합인 경우 해당 간선은 MST에 포함 x
		if (Find(e.start)!= Find(e.end)) {
			Union(e.start, e.end);
			ans += e.weight; // 가중치 합
			if (max_wei < e.weight) max_wei = e.weight;
		}
	}
	ans -= max_wei;
	cout << ans;
}


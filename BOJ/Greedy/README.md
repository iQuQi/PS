# 😈 Greedy (탐욕법)
> 현재 상황에서 지금 당장 좋은 것만 고르는 방법

<br/>

## 소개
1. 유형이 매우 다양하므로 항상 잘 풀 수 있는 것은 아님 -> **많은 유형을 접해보고 훈련이 필요**
2. 특정 문제를 만났을 때 그리디로 풀 수 있는 지 파악하는 것이 중요
  - 그리디 알고리즘은 기준에 따라 좋은 것만 선택하는 알고리즘이므로 '가장 큰 순서대로'와 같은 기준을 알게 모르게 제시한다.
  - 즉, 대체로 정렬 알고리즘과 짝을 이뤄 출제된다.

<br/>

## 대표적인 문제: 동전 거슬러 주기
  -  500원 100원 50원 10원이 있을 때 최소한의 동전 개수로 손님에게 돈을 거슬러주는 방법
  -  큰 단위 화폐부터 차례대로 주면 됨
  - 화폐의 종류(k)만큼 반복하므로 O(k) -> 거슬러줘야할 금액의 크기와 무관
    ```python
    n = 1260
    count = 0

    coin_types = [500, 100, 50, 10]
    for coin in coin_types:
      count += n // coin
      n %= coin

    print(count)
    ```

<br/>

## 알고리즘의 정당성
- 대부분의 문제에서는 그리디 알고리즘으로 최적의 해를 찾을 수 없음 -> 그리디로 해법을 찾은 경우 정당한지 검사해야 함
- **동전 문제 정당성 증명**: 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다.
- 동전 문제에서 배수 단위가 아니라 무작위로 주어졌다면 그리디 문제 X
    ```python
    n = 1260
    # 화폐 단위가 500 100 50 10인 경우 - 서로가 배수
        case 1  case 2  ....
    500 2       1
    100 2       7
    50  1       1
    10  1       1
    => 한 단계 아래 화폐로 한 단계 위 화폐 단위를 넘겨버리면 항상 교환 가능
    => 즉, 항상 동전의 개수가 작아지는 방향의 최적의 해가 존재
    => 교환을 최대로 해서 개수를 줄이는 것이 최적의 해임

    # 화폐 단위가 300 200 10인 경우 - 서로 배수 x
        case 1  case 2  ....
    700 1       0
    200 2       6
    10  16      6
    => 한 단계 아래 화폐로 한 단계 위 화폐 단위 보다 많이 모아도 교환이 항상 가능한 것은 아님
    => 즉, 동전의 개수가 작아지는 방향의 최적의 해가 항상 존재하지는 않음
    => 그리디가 반드시 통하는 것이 아니므로 이 경우 그리디 알고리즘을 적용하지 않음
    ```

<br/>

## 실전
1. 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정다안지 검토할 수 있어야 함
2. 코딩 테스트에서 문제 유형을 파악하기 어렵다면 우선 그리디를 의심 -> 안되면 DP나 그래프

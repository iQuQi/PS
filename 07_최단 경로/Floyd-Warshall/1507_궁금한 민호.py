'''
강호는 N개의 도시로 이루어진 나라에 살고 있다. 각 도시는 M개의 도로로 연결되어 있으며, 
각 도로를 지날 때 필요한 시간이 존재한다. 도로는 잘 연결되어 있기 때문에, 
도시 A에서 B로 이동할 수 없는 경우는 존재하지 않는다.

도시 A에서 도시 B로 바로 갈 수 있는 도로가 있거나, 다른 도시를 거쳐서 갈 수 있을 때, 
도시 A에서 B를 갈 수 있다고 한다.

강호는 모든 쌍의 도시에 대해서 최소 이동 시간을 구해놓았다. 
민호는 이 표를 보고 원래 도로가 몇 개 있는지를 구해보려고 한다.

예를 들어, 예제의 경우에 모든 도시 사이에 강호가 구한 값을 가지는 도로가 존재한다고 해도 된다. 
하지만, 이 도로의 개수는 최솟값이 아니다. 
예를 들어, 도시 1-2, 2-3, 1-4, 3-4, 4-5, 3-5를 연결하는 도로만 있다고 가정해도, 
강호가 구한 모든 쌍의 최솟값을 구할 수 있다. 이 경우 도로의 개수는 6개이고, 모든 도로의 시간의 합은 55이다.

모든 쌍의 도시 사이의 최소 이동 시간이 주어졌을 때, 이 나라에 존재할 수 있는 도로의 개수의 최솟값일 때, 
모든 도로의 시간의 합을 구하는 프로그램을 작성하시오.
'''
'''
못품 - 풀이
i -> j로 가는 최단경로와 i -> k, k -> j 로 가는 최단경로의 합이 같다면 i -> j경로는 없애준다.
i -> j의 최단경로가 더 크다면 입력이 잘못된 것이므로 result를 -1로 저장해준다.
없애준 경로를 제외하고 값을 더해준 다음 출력해준다.
'''
import sys

input = sys.stdin.readline
n = int(input())
s = []
s_ = [[True] * n for i in range(n)]
result = 0

for i in range(n):
  s.append(list(map(int, input().split())))

for k in range(n):
  for i in range(n):
    for j in range(n):
      # i == j 는 필수는 아님. 나머지 두 조건은 필수
      if i == j or j == k or i == k: continue
      if s[i][j] == s[i][k] + s[k][j]: s_[i][j] = False
      elif s[i][j] > s[i][k] + s[k][j]: result = -1

if result != -1:
  for i in range(n):
    for j in range(i, n):
      # 최소개의 간선의 비용 합 구하기
      if s_[i][j]: result += s[i][j]

print(result)
